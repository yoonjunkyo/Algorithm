[알고리즘]
알고리즘은 어떤 일을 해결하기 위한 방법이다. 어떠한 문제를 풀어내기 위해 정해진 일련의 절차나 
방법을 공식화한 형태로 표현한 것, 계산을 실행하기 위한 단계적 절차를 의미한다.
즉, 문제풀이에 필요한 계산절차 또는 처리과정의 순서를 뜻한다.

-구현 : 재귀적 알고리즘, 연역적 알고리즘, 결정론적 알고리즘, 근사 알고리즘, 양자 알고리즘 등.
-설계 : 무차별 대입 공격, 분할 정복 알고리즘, 그래프 순회, 분기 한정법, 확률적 알고리즘, 리덕션, 
백트래킹 등.
-최적화 문제 : 선형 계획법, 동적 계획법, 탐욕 알고리즘, 휴리스틱 함수 등.
-이론적 분야 : 검색 알고리즘, 정렬 알고리즘, 수치 알고리즘, 그래프 알고리즘, 문자열 알고리즘,
암호학적 알고리즘, 기계 학습, 데이터 압축 등.

--------------------------------------------------------------------------------------------------------

Algorithm
-> 적절한 STL과 자료구조 사용이 핵심

- 정렬(sort)
선택정렬  1번째 index부터 뒤에 배열과 비교 가장 작은수를 선택해서 교환
삽입정렬  2번째 index부터 앞 쪽 배열과 비교 -> 적절한 위치에 삽입
버블정렬  인접한 배열끼리 비교 -> 모두 정렬이 될 때까지 스캔 반복
퀵정렬     피벗보다 큰 원소는 왼쪽에 작은 원소는 오른쪽에 -> 재귀를 이용하여 앞 , 뒤로 불러옴

- 동적 계획법
 : 특정 범위까지의 값을 구하기 위해서 그것과 다른 범위까지의 값을 이용하여 효율적으로 값을 
   구하는 알고리즘
-> 메모이제이션
-> 피보나치 Top Down
int memo[100]{}; //메모이제이션 공간. 전역 변수이므로 0으로 초기화
int fibonacci(unsigned int n)
{
  if (n<=1) //0번째, 1번째 피보나치 수
    return n;
  if (memo[n]!=0) //메모가 있는지 확인(0으로 초기화되었으므로 0이 아니라면 메모가 쓰인 것임)
    return memo[n]; //메모 리턴
  memo[n]=fibonacci(n-1) + fibonacci(n-2); //작은 문제로 분할
  return memo[n];
}
-> 피보나치 Bottom Up
int f_data[N] = {1, 1}; // N은 정의하기 나름
int last_pos = 1; // 마지막으로 계산한 지점. 이 코드에선 이미 f_data[1]까지 정의되어있기 때문에 1로 초기화한다.
int f(int n) //피보나치 수열의 제 n항을 구한다. 배열의 관점에서는 n-1번째 요소를 구하는 것.
{
    int i;
    if(f_data[n-1] == 0)  // 아직 구한 적이 없으면 구한다
    {
        for(i=last_pos+1; i<n; ++i)
        {
            f_data[i] = f_data[i-1] + f_data[i-2];
        }
        last_pos = n-1;
    }
    return f_data[n-1];
}

- DFS & BFS

- 해시 테이블, 해시맵

- 슬라이딩 윈도우

- 비트마스크

- 최장 공통 부분 문자열(LCS)

- 이분 탐색(Binary Search)
 : 오름차순으로 정렬된 리스트에서 특정한 값의 위치를 찾는 알고리즘
 처음 중간의 값을 임의의 값으로 선택하여, 그 값과 찾고자 하는 값의 크고 작음을 비교하는 방식

- 최소 스패닝 트리

- 탐욕법(Greedy)

- 다익스트라(Dijkstra) 알고리즘

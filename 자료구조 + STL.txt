[자료구조]

자료구조는 말 그대로 자료(data)를 담는 구조이다. 
자세히 말하면 컴퓨터 과학에서 접근 및 수정을 가능케 하는 자료의 조직, 관리, 저장을 의미한다. 
자료 구조는 데이터 값의 모임, 데이터 간의 관계, 그리고 데이터에 적용할 수 있는 함수나 명령을 
의미한다. 

*구현에 따라
-배열 : 가장 일반적인 구조이다. 메모리 상에 같은 타입의 자료가 연속적으로 저장된다. 
튜플 : 둘 이상의 자료형을 묶음으로 다루는 구조이다.
-연결 리스트 : 노드를 단위로 한다. 노드는 자료와 다음 노드를 가리키는 참조값으로 구성되어 있다. 
노드가 다음 노드로 아무것도 가리키지 않으면 리스트의 끝이다.
-원형 연결 리스트 : 각 노드는 다음 노드를 가리키고, 마지막 노드가 처음 노드를 가리키는 연결 
리스트이다.
-이중 연결 리스트 : 각 노드는 이전 노드와 다음 노드를 가리키는 참조값으로 구성된다. 처음 노드의 
이전 노드와 마지막 노드의 다음 노드는 없다.
-환형 이중 연결 리스트 : 처음 노드가 이전 노드로 마지막 노드를 가리키고, 마지막 노드가 다음 
노드로 처음 노드를 가리키는 이중 연결 리스트이다.
-해시 테이블 : 개체가 해시값에 따라 인덱싱된다.

*형태에 따라

<선형 구조>
-스택 : 스택 자료구조에 먼저 저장된 것이 꺼내어 쓸 때는 제일 나중에 나온다. 
-큐 : 스택과 반대로 큐 자료구조에 먼저 저장된 것이 제일 먼저 나온다.
-환형 큐 : 한정된 길이 안에서 부수적인 작업 없이 읽고 쓰기를 할 수 있는 큐이다.
-덱 : 양쪽에서 넣기와 빼기를 할 수 있는 일반화된 선형 구조이다.

<비선형 구조>
-그래프 : 꼭짓점과 꼭짓점을 잇는 변으로 구성된다.
-유향 그래프, 무향 그래프 : 변이 방향성을 갖는지 갖지 않는지에 따른 그래프의 분류이다.
-트리 : 뿌리와, 뿌리 또는 다른 꼭짓점을 단 하나의 부모로 갖는 꼭짓점들로 이루어진 구조. 
부모 자식 관계는 변으로 표현된다.
-이진 트리 : 자식이 최대 두 개인 트리.
-힙 : 이진트리의 일종으로 이진트리에 어떤 특성을 부여한 것이라 할 수 있다.

---------------------------------------------------------------------------------------------------

*
Array
-> index로 빠르게 값을 찾는 것이 가능함
LinkedList
-> 데이터의 삽입 및 삭제가 빠름
-> 한 노드에 연결될 노드의 포인터 위치를 가리키는 방식
ArrayList
-> 데이터를 찾는데 빠르지만, 삽입 및 삭제가 느림

*Stcak
->LIFO (Last In First Out, 후입선출) : 가장 나중에 들어온 것이 가장 먼저 나옴
->함수의 콜스택, 문자열 역순 출력, 연산자 후위표기법

*Queue
->FIFO (First In First Out, 선입선출) : 가장 먼저 들어온 것이 가장 먼저 나옴
->버퍼, 많이 입력된 데이터를 처리하지 못하고 있는 상황, BFS

*Heap
 : 우선순위 큐를 위해 만들어진 자료구조
-> 우선순위 큐?
 : 데이터들이 우선순위를 가지고 있음. 우선순위가 높은 데이터가 먼저 나감
->시뮬레이션 시스템, 작업 스케줄링, 수치해석 계산

->최대힙(max heap) : 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리
->최소힙(min heap) : 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리

->힙의 삽입
 1.힙에 새 요소가 들어오면, 일다나 새로운 노드를 힙의 마지막 노드에 삽입
 2.새로운 노드를 부모 노드들과 교환

*Tree
 : Node와 Edge로 이루어진 자료구조
  가장 중요한 것은, 그래프와 트리의 차이가 무엇인가인데, 이는 사이클의 유무로 설명할 수 있음
->순회방식
1.전위순회(pre-order) : 각 루트를 순차적으로 먼저 방문
2.중위순회(in-order) : 왼쪽 하위 트리를 방문 후 루트를 방문(왼쪽 자식 → Root → 오른쪽 자식)
3.후위순회(post-order) : (왼쪽 자식 → 오른쪽 자식 → Root)
4.레벨순회(level-order) : 루트(Root)부터 계층 별로 방문하는 방식
 
*Binary Search Tree(BST)
 : 각 노드의 왼쪽 자식은 부모보다 작고, 오른쪽 자식은 부모보다 큼
  중복된 노드가 없어야함
 -> in-order 방식으로 탐색

*Graph
 1.인접 행렬(Adjacency Matrix)
 2.인접 리스트(Adjacency List)

*Hash map

**Cpp STL

Pair
- pair를 사용하면 두 자료형 T1과 T2를 묶을 수 있음
- 첫번째 자료는 first , 두번째 자료는 second로 접근!
- make_pair() 를 통해 만들 수 있다
- #include <algorithm> or #include <vector>

Tuple
- pair와 같지만 여러개를 묶을 수 있다
- make_tuple() 으로 만들 수 있음
- 인덱스를 통해 접근 가능
- get<index>(tuple)

시퀀스컨테이너-----------------------------------

Vector
- vector 컨테이너는 대표적인 시퀀스 컨테이너로 배열과 비슷하여 자주 사용함
- 길이를 변경 할 수 있는 배열
- vector<vector<int>> v 로 선언하여 2차원 배열로 사용 가능

Deque
- 벡터와 비슷한 컨테이너지만 벡터의 메모리 할당 단점을 보완
- Vector는 새로운 원소를 삽입할 때 할당된 메모리가 부족하면 이전 메모리 블록을 삭제하고, 
  새로운 메모리 블록을 재할당하며 이전 원소를 모두 복사
- Deque은 새로운 단위의 메모리 블록을 할당하고 원소를 삽입
- 또한, 새로운 원소를 순차열 중간에 삽입, 제거 하더라도 원소의 개수가 작은쪽으로 밀어냄
- 시작과 끝에서 삽입, 삭제 가능
- d.push_back()         // data 추가 (끝에서)
- d.push_front()        // data 추가 (시작점에서)
- d.pop_back()         // data 삭제 (끝에서)
- d.pop_front()         // data 삭제 (시작점에서)

List
- List 컨테이너는 vector와 deque처럼 시퀀스 컨테이너로 원소가 상대적인 순서를 유지함
- 그러나 list는 노드 기반 컨테이너로 원소가 노드 단위로 저장되며 list는 이중 연결 리스트로 구현된다
- l.sort()                                // 오름차순 정렬
- l.sort(greater<int>())          // 내림차순 정렬

String

연관컨테이너-----------------------------------
 : 키(key)와 값(value)처럼 관련있는 데이터를 하나의 쌍으로 저장하는 컨테이너

Set
- set 컨테이너는 연관 컨테이너 중 단순한 컨테이너로 key라 불리는 value의 집합으로 이루어진 컨테이너이다
- 모든 연관 컨테이너는 노드 기반 컨테이너이며 균형 이진트리로 구현되므로 균형 이진트리의 모든 특징을 갖는다
- key의 집합이기 때문에 중복값을 허용하지 않음
- s.erase(it)        // 원소삭제  - 삭제를 하면 다음 노드를 가르킴
-> pair형 비교를 위해 사용자 정의 비교자 함수 필요

Map
- map 컨테이너는 연관 컨테이너 중 자주 사용하는 컨테이너로 원소를 key, value 쌍으로 저장한다
- set 은 원소로 key 하나만을 저장하지만, map 은 key, value 를 저장한다
- map 또한 중복 key 허용하지 않는다 ( 만약 중복 key를 저장해야 한다면 multimap 사용 )

multiset
-set과 구별되는 multiset의 가장 큰 특징은 key값이 중복됨

multimap
-key값이 중복 가능

-----------------------------------
Stack
- 컨테이너 어댑터의 종류는 Stack, Queue, Priority_queue가 있다
- 그 중, 대표적인 컨테이너 어댑터는 stack 이다
- LIFO 방식의 시퀀스

Queue
- Stack 과는 다른 FIFO 방식의 시퀀스
- BFS (Breadth First Search, 너비우선탐색)

Priority_queue
- Queue가 FIFO 방식인 반면, Priority_queue는 빠지는건 최소, 혹은 최대부터 !!
- push 와 pop이 O(log n) 시간에 처리된다
- 최대부터 빠지는 힙을 Max Heap , 최소부터 빠지는 힙을 Min Heap 이라 한다

Heap
-완전이진트리(complete binary tree)를 기본으로 한 자료구조
-make_heap 범위 내 원소들을 힙 속성을 만족하도록 만듬.
-push_heap 힙에 원소를 삽입. (컨테이너가 힙 속성을 만족한다고 가정함.)
-pop_heap 힙에 원소를 제거. (컨테이너가 힙 속성을 만족한다고 가정함.)
->
  vector<int> vec { 3, 2, 4, 1, 5, 9 };
  make_heap(vec.begin(), vec.end());
  v.push_back(6);
  push_heap(v.begin(), v.end());
